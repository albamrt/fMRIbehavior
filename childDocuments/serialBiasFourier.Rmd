---
title: ''
output: html_document
---
```{r include = FALSE}
require(knitr)
opts_knit$set(root.dir=normalizePath('../'))
knitr::opts_chunk$set(echo = FALSE, fig.align='center', fig.pos = 'H', message = FALSE, warning = FALSE)
options(knitr.kable.NA = '')
```

```{r}
load("data/preproc_data.RData")
source('helpers/helpers.R')
source('helpers/settings.R')
```

```{r message = FALSE}
Sigma <- seq(0.1, 1.9, by = 0.05)
```


```{r eval = FALSE}
groupedData <- data %>%
  group_by(group, session) %>%
  nest() %>%
  mutate(JV10e = map(.x = data, .f = ~mixturer:::bays_2009_error(X = .x$fourier_R, Tg = .x$S_rad))) %>%
  mutate(JV10 = map(.x = data, .f = ~mixturer:::bays_2009_fit(X = .x$fourier_R, Tg = .x$S_rad, return.ll = TRUE))) %>%
  mutate(precision = map_dbl(JV10e, 1), 
         bias = map_dbl(JV10e, 2),
         L = unlist(map(.x = JV10, .f = ~.x$LL)),
         K = unlist(map(.x = JV10, .f = ~.x$B['K'])),
         Pt = unlist(map(.x = JV10, .f = ~.x$B['Pt'])),
         Pu = unlist(map(.x = JV10, .f = ~.x$B['Pu'])),
         sd = k2sd(K),
         precision_mixture = 1/sd,
         time = unlist(map(data, function(x) unique(x['time'])))) 
#Cross-validation to find hyperparameter sigma
groupedData %>%
  mutate(sim = map(data, function(x) lapply(Sigma, function(y)
    replicate(1000, crossValSigma(y, x, derivative = 1))))) 
#save(groupedData, file = '/Users/albamorato/Documents/IDIBAPS/ANMDA/MRI/behaviour/groupedData.RData')

groupedData %>%
  mutate(sim3 = map(data, function(x) lapply(Sigma, function(y)
    replicate(1000, crossValSigma(y, x, derivative = 3))))) 
save(groupedData, file = 'data/groupedData.RData')

groupedData <- groupedData %>%
  mutate(mean_MSE = map(.x = sim, .f = function(x) unlist(lapply(x, mean))),
         mean_MSE3 = map(.x = sim3, .f = function(x) unlist(lapply(x, mean))),
         min_MSE = unlist(map(.x = mean_MSE, .f = min)),
         min_MSE3 = unlist(map(.x = mean_MSE3, .f = min)),
         sigma = unlist(map(.x = mean_MSE, .f = function(x) Sigma[x == min_MSE])),
         sigma3 = unlist(map(.x = mean_MSE3, .f = function(x) Sigma[x == min_MSE3])),
         data = map2(.x = data, .y = sigma, 
                     .f = function(x, y) mutate(x, DoG = dnorm_deriv1(x$diffstim, 
                                                                      mean = 0, sd = y))),
         data = map2(.x = data, .y = sigma3, 
                     .f = function(x, y) mutate(x, DoG3 = dnorm_deriv3(x$diffstim, 
                                                                      mean = 0, sd = y))),
         mod = pmap(.l = list(d = data, min = min_MSE, min3 = min_MSE3), 
                    .f = function(d, min, min3) if(min < min3){
                      lm(fourier_error ~ time*DoG, 
                          data = d, na.action = na.omit)}else{
                            lm(fourier_error ~ time*DoG3, 
                                data = d, na.action = na.omit)}),
         data = map2(.x = mod, .y = data, 
                     function(x, y) mutate(y, pred = predict(x, newdata = y, 
                                                                 level = 0))))
```

```{r}
#Cross-validation to find hyperparameter sigma
sim <- lapply(Sigma, function(x) replicate(100, crossValSigma(x, data, derivative = 1)))
sim3 <- lapply(Sigma, function(x) replicate(100, crossValSigma(x, data, derivative = 3)))

save(sim, sim3, file = "data/sim.RData")
```

```{r}
load(file = 'data/sim.RData')

mean_MSE <- unlist(lapply(sim, mean))
min_MSE <- min(mean_MSE)
sigma <- Sigma[mean_MSE == min_MSE]

mean_MSE3 <- unlist(lapply(sim3, mean))
min_MSE3 <- min(mean_MSE3)
sigma3 <- Sigma[mean_MSE3 == min_MSE3]

#data$DoG <- dnorm_deriv1(data$diffstim, mean = 0, sd = sigma)
#data$DoG3 <- dnorm_deriv3(data$diffstim, mean = 0, sd = sigma3)

data$DoG <- dog1(sigma = sigma, x = data$diffstim)
data$DoG3 <- dog3(sigma = sigma, x = data$diffstim)

diffstims <- seq(-pi/2, pi/2, length.out = 30)
#DoG <- dnorm_deriv1(diffstims, mean = 0, sd = sigma)
#DoG3 <- dnorm_deriv3(diffstims, mean = 0, sd = sigma3)
DoG <- dog1(sigma = sigma, x = diffstims)
DoG3 <- dog3(sigma = sigma, x = diffstims)

par(mfrow = c(1, 2))
plot(Sigma, mean_MSE, type = 'l', 
     ylim = c(min(c(mean_MSE, mean_MSE3)), max((c(mean_MSE, mean_MSE3)))))
lines(Sigma, mean_MSE3, col = 'orange')

plot(diffstims, DoG, type = 'l', 
     ylim = c(min(na.omit(c(DoG, DoG3))), max(na.omit((c(DoG, DoG3))))))
lines(diffstims, DoG3, col = 'orange')
```


```{r}
if(min_MSE < min_MSE3){
  mod <- lme(fourier_error ~ group*time*DoG,  random = ~(1+group+time)|subject, 
             data = data, na.action = na.omit)
}else{mod <- lme(fourier_error ~ group*time*DoG3, random = ~(1+group)|subject, 
                 data = data, na.action = na.omit)
}

summary(mod)$tTable %>%
  kable(digits = digits, booktabs = TRUE, escape = FALSE,
        caption = 'Summary of a linear model where the response is the error and regressors are group, time, a derivative of gaussian and its interaction.') %>%
    kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)

anova(mod) %>%
  kable(digits = digits, booktabs = TRUE, escape = FALSE,
        caption = 'Anova of a linear model where the response is the error and regressors are group, time, a derivative of gaussian and its interaction.') %>%
    kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)
```

```{r}
# Predictions:
mod_fit <- data.frame(x = data[,'diffstim'], group = data[, 'group'], 
                      time = data[,'time'], subject = data[,'subject'])
mod_fit$session <- factor(mod_fit$time, levels = c(0, 0.25, 0.5, 1, 2), labels = c('S1', 'S2', 'S3', 'S4', 'S5'))
if('DoG' %in% names(mod$coefficients$fixed)){
  mod_fit$DoG <- dnorm_deriv1(mod_fit$x, mean = 0, sd = sigma)
}else{mod_fit$DoG3 <- dnorm_deriv3(mod_fit$x, mean = 0, sd = sigma3)
}
mod_fit <- mod_fit[complete.cases(mod_fit),]
mod_fit$pred <- predict(mod, newdata = mod_fit, level = 0)
```


```{r warning = FALSE}
window = pi/3
step = pi/20

gr <- split(data, 
            list(data$group, data$session), drop = TRUE)
serialbias <- lapply(gr, function(x) 
  serial_bias(prevcurr = x$diffstim, error = x$fourier_error, window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(serialbias, aes(x = x, y = m)) +
  geom_line(linetype = 'dashed', aes(color = group)) +
  geom_hline(yintercept=0) +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.2) +
  geom_line(data = mod_fit, aes(x = x, y = pred, color = group), size = 1) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  ggtitle('Serial bias') + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```


```{r warning = FALSE}
data %>%
  ggplot(aes(x = diffstim, y = fourier_error), fill = group) +
  stat_smooth(aes(fill = group, color = group), linetype = 'dashed', 
              method = "loess", span = window, alpha = 0.2) +
  geom_line(data = mod_fit, aes(x = x, y = pred, color = group), size = 1) +
  geom_hline(yintercept = 0, color = "black") +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  labs(x = "Difference previous - current stimulus") 
```


```{r warning = FALSE}
window = pi/5
step = pi/20
foldedserialbias <- lapply(gr, function(x) 
  folded_serial_bias(prevcurr = x$diffstim, error = x$fourier_error, window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(foldedserialbias, aes(x = x, y = m)) +
  geom_line(linetype = 'dashed', aes(color = group)) +
  geom_hline(yintercept=0, color = "black") +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.2) +
  geom_line(data = mod_fit[mod_fit$x>0,], aes(x = x, y = pred, 
                                                color = group), size = 1) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  ggtitle('Folded serial bias') + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```

```{r warning = FALSE}
data %>%
  ggplot(aes(x = abs(diffstim), y = fourier_error*sign(diffstim)), fill = group) +
  stat_smooth(aes(fill = group, color = group), method = "loess", 
              span = window, linetype = 'dashed', alpha = 0.2) +
  geom_line(data = mod_fit[mod_fit$x>0,], aes(x = x, y = pred, 
                                                color = group), size = 1) +
  geom_hline(yintercept=0, color = "black") +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```

```{r warning = FALSE, fig.height = 40, fig.width = 8, fig.cap = 'Folded serial bias by subject and session', eval = FALSE}
window = pi/4
step = pi/20

subj_sb <- split(data, 
            list(data$subject, data$session), drop = TRUE)
subj_foldedserialbias <- lapply(subj_sb, function(x) 
  folded_serial_bias(prevcurr = x$diffstim, error = x$fourier_error, 
                     window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1), subject = substr(id, 1, 3)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(subj_foldedserialbias, aes(x = x, y = m), color = group) +
  geom_line() +
  geom_hline(yintercept=0, color = "black") +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.4) +
  geom_line(data = mod_fit[mod_fit$x>0,], aes(x = x, y = pred, color = group), size = 1) +
  facet_wrap(~ subject + session, ncol = 4) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  ggtitle('Folded serial bias') + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
``` 

```{r fig.height = 60, fig.width = 8, fig.cap = 'Folded serial bias by subject and session', warning = FALSE}
data %>%
  ggplot(aes(x = abs(diffstim), y = fourier_error*sign(diffstim)), fill = group) +
  stat_smooth(aes(fill = group, color = group), method = "loess",
              span = window, linetype = 'dashed', alpha = 0.2) +
  geom_hline(yintercept = 0, color = "black") +
  geom_line(data = mod_fit[mod_fit$x>0,], aes(x = x, y = pred, color = group), size = 1) +
  facet_wrap(~ subject + session, ncol = 4) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```


```{r fig.height = 5, fig.width = 8, fig.cap = 'Folded serial bias by group and session. Here the fit (solid line) is computed as the mean of individual fits.', warning = FALSE}
mod_fit2 <- mod_fit %>%
  group_by(x, group) %>%
  mutate(y = mean(pred))
  
data %>%
  ggplot(aes(x = abs(diffstim), y = fourier_error*sign(diffstim)), fill = group) +
  stat_smooth(aes(fill = group, color = group), method = "loess",
              span = window, linetype = 'dashed', alpha = 0.2) +
  geom_hline(yintercept = 0, color = "black") +
  geom_line(data = mod_fit2[mod_fit2$x>0,], aes(x = x, y = pred, color = group), 
            size = 1) +
  facet_wrap(~ group + session, ncol = 4) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```


```{r}
groupedSubjSes <- data %>%
  group_by(session, subject) %>%
  nest() %>%
  mutate(group = substr(subject, 1,1), 
         time = unlist(map(data, function(x) unique(x['time']))))  %>%
  mutate(foldedserialbias = map(.x = data, .f = function(x) 
    folded_serial_bias(prevcurr = x$diffstim, error = x$fourier_error, window = window,
                       step = step)),
    mean_folded = unlist(map(foldedserialbias, function(x) mean(x$m, na.rm = TRUE))))

groupedSubjSes %>%
  group_by(group, session) %>%
  nest() %>%
  mutate(m = unlist(map(data, function(x) mean(na.omit(x$mean_folded)))), 
         s = unlist(map(data, function(x) sd(na.omit(x$mean_folded)))),
         n = unlist(map(data, function(x) nrow(x))),
         se = s/n,
         lower = m - se,
         upper = m + se,
         width = unlist(map(data, function(x) nrow(x)*0.01)),
         time = recode(session, S1 = 0, S2 = 3/12, S3 = 6/12, S4 = 12/12, S5 = 24/12)) %>%
  group_by(time) %>%
  mutate(
    width = 0.05 * n()
  ) %>%
  ggplot(aes(x = time, y = m, color = group)) +
  geom_point(position = position_dodge(width = 0.15)) + 
  geom_errorbar(aes(ymin = lower, ymax = upper, color = group, width = width), 
                position = position_dodge(width = 0.15)) +
  geom_point(data = groupedSubjSes, aes(x = time, y = mean_folded, 
                                        colour = group),  
             position = position_jitterdodge(dodge.width = 0.15,
                                             jitter.width = 0.05), 
             alpha = 0.3) +
  geom_hline(yintercept=0) +
  scale_color_manual(values=colors) +
  ylab('Mean folded serial bias')
```
