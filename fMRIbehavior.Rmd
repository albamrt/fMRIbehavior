---
title: "fMRI behavior"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
  encoding = encoding,
  output_file = file.path(dirname(input_file), out_dir, 'index.html'))})
date: "`r format(Sys.time(), '%d/%m/%y')`"
output: html_document
---

<style type="text/css">

h1.title {
  font-size: 38px;
  color: Black;
  text-align: center;
}
h4.date {
  font-size: 18px;
  color: Black;
  text-align: center;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align='center', fig.pos = 'H')
options(knitr.kable.NA = '')
#install.packages(c("circular", "dplyr", "ggforce", "knitr", "lme4", "lmerTest", "Publish", "tidyr", "tidyverse", "Hmisc"))
library(readr)
library(Hmisc)
require(dplyr)
require(tibble)
require(tidyverse)
require(tidyr)
require(circular)
require(knitr)
require(Publish)
require(ggforce)
require(nlme)
require(Hmisc)
require(reticulate)
require(data.table)
require(readxl)
require(kableExtra)
require(lme4)
```

```{r functions}
# Bays mixture model functions:
source("/Users/albamorato/Documents/IDIBAPS/ANMDA/MRI/behaviour/precision-mixture-model-master/mixture_model_functions.R")

summaryHist <- function(data, variable){
  ggplot(data, aes(x = data[,variable])) +
  geom_histogram(aes(y =..density..), bins = 30, color = "gray",
                 position = 'identity', alpha = 0.4) +
  labs(x = label(data[,variable]))
}

fitMixtStim <- function(data){
  mod <- JV10_fit(X = data$R_rad, Tg = data$S_rad, NT = data$prevstim_rad, return.ll = TRUE)
  mod <- setNames(as.data.frame(mod),c("K", "Pt", "Pnt", "Pu", "LL"))
  mod
}

fitMixtResp <- function(data){
  mod <- JV10_fit(X = data$R_rad, Tg = data$S_rad, NT = data$prevresp_rad, return.ll = TRUE)
  mod <- setNames(as.data.frame(mod),c("K", "Pt", "Pnt", "Pu", "LL"))
  mod
}

fitMixtProbe <- function(data){
  mod <- JV10_fit(X = data$R_rad, Tg = data$S_rad, NT = data$prevprob_rad, return.ll = TRUE)
  mod <- setNames(as.data.frame(mod),c("K", "Pt", "Pnt", "Pu", "LL"))
  mod
}

YgVal <- function(cdat, ndat, g) {
  N <- length(cdat) ; ndatcsum <- cumsum(ndat)
  delhat <- 0 ; tbar <- 0
  for (k in 1:g) {
    sample <- circular(0)
    if (k==1) {low <- 0} else
      if (k > 1) {low <- ndatcsum[k-1]}
    for (j in 1:ndat[k]) { sample[j] <- cdat[j+low] }
    tm1 <- trigonometric.moment(sample, p=1)
    tm2 <- trigonometric.moment(sample, p=2)
    Rbar1 <- tm1$rho; Rbar2 <- tm2$rho ; tbar[k] <- tm1$mu
    delhat[k] <- (1-Rbar2)/(2*Rbar1*Rbar1)
  }
  dhatmax <- max(delhat) ; dhatmin <- min(delhat)
  if (dhatmax/dhatmin <= 4) {
    CP <- 0 ; SP <- 0 ; dhat0 <- 0
    for (k in 1:g) {
      CP <- CP+ndat[k]*cos(tbar[k]) ; SP <- SP+ndat[k]*sin(tbar[k])
      dhat0 <- dhat0+ndat[k]*delhat[k] }
    dhat0 <- dhat0/N
    RP <- sqrt(CP*CP+SP*SP) ; Yg <- 2*(N-RP)/dhat0
    return(Yg) } else
      if (dhatmax/dhatmin > 4) {
        CM <- 0 ; SM <- 0 ; Yg <- 0
        for (k in 1:g) {
          CM <- CM+(ndat[k]*cos(tbar[k])/delhat[k])
          SM <- SM+(ndat[k]*sin(tbar[k])/delhat[k])
          Yg <- Yg+(ndat[k]/delhat[k]) }
        RM <- sqrt(CM*CM+SM*SM) ; Yg <- 2*(Yg-RM)
        return(Yg) }
}


serial_bias <- function(prevcurr, error, window, step){
  d <- data.frame(prevcurr = prevcurr, error = error)
  d <- d[complete.cases(d),]
    xxx = seq(-pi/2, pi/2, step)
    m_err <- c()
    std_err <- c()
    for(t in xxx){
      idx = ((d$prevcurr>=t-window/2) & (d$prevcurr<t+window/2))
      if(t-window/2 < -pi/2){
        idx = ((d$prevcurr>=t-window/2) & (d$prevcurr<t+window/2) | (d$prevcurr>pi/2-(window/2-(pi/2-abs(t)))))
      }
      if(t+window/2 > pi/2){
        idx = ((d$prevcurr>=t-window/2) & (d$prevcurr<t+window/2) | (d$prevcurr<=pi/2+(window/2-(pi/2-abs(t)))))
      }
       m_err <- c(m_err, mean.circular(circular(d$error[idx], 
                                                units = 'radians', 
                                                template = 'geographics')))
        std_err <- c(std_err, (sd.circular(circular(d$error[idx],
                                            units = 'radians', template = 'geographics'))
                       /sqrt(sum(idx))))
    }
    return(data.frame(x = xxx, m = m_err, sd = std_err, 
                      yl = m_err - std_err, yh = m_err + std_err))}


folded_serial_bias <- function(prevcurr, error, window, step){
  d <- data.frame(prevcurr = abs(prevcurr), error = error*sign(prevcurr))
  d <- d[complete.cases(d),]
    xxx = seq(-pi/2, pi/2, step)
    m_err <- c()
    std_err <- c()
    for(t in xxx){
      idx = ((d$prevcurr>=t-window/2) & (d$prevcurr<t+window/2))
       m_err <- c(m_err, mean.circular(circular(d$error[idx], 
                                                units = 'radians', 
                                                template = 'geographics')))
        std_err <- c(std_err, (sd.circular(circular(d$error[idx],
                                            units = 'radians', template = 'geographics'))
                       /sqrt(sum(idx))))
    }
    return(data.frame(x = xxx, m = m_err, sd = std_err, 
                      yl = m_err - std_err, yh = m_err + std_err))}

fourier_fit <- function(x = NULL, n = NULL, up = 10L, plot = TRUE, add = FALSE, main = NULL, ...){
  N <- length(x)
  #The direct transformation
  #The first frequency is DC, the rest are duplicated
  dff = fft(x)
  #The time
  t = seq(from = 1, to = length(x))
  #Upsampled time
  nt = seq(from = 1, to = length(x)+1-1/up, by = 1/up)
  #New spectrum
  ndff = array(data = 0, dim = c(length(nt), 1L))
  ndff[1] = dff[1] #Always, it's the DC component
  if(n != 0){
    ndff[2:(n+1)] = dff[2:(n+1)] #The positive frequencies always come first
    #The negative ones are trickier
    ndff[length(ndff):(length(ndff) - n + 1)] = dff[length(x):(length(x) - n + 1)]
  }
  #The inverses
  indff = fft(ndff/(N+1), inverse = TRUE)
  idff = fft(dff/(N+1), inverse = TRUE)
  if(plot){
    if(!add){
      plot(x = t, y = x, pch = 16L, xlab = "Bin", ylab = "Measurement",
           main = ifelse(is.null(main), paste(n, "harmonics"), main))
      lines(y = idff, x = t, col = adjustcolor(1L, alpha = 0.5))
    }
    lines(y = indff, x = nt, ...)
  }
  ret = data.frame(time = nt, y = Mod(indff))
  return(ret)
}
```

```{r data}
data <- read.csv("~/Documents/IDIBAPS/ANMDA/MRI/behaviour/behaviour.csv", sep=";")

# Add continuous time variable (instead of session):
data$time <- recode(data$session, S1 = 0, S2 = 3, S3 = 6, S4 = 12, S5 = 24) 

# Label data:
label(data$trial) = "Trial number"
label(data$block) = "Block number"
label(data$run) = "Run"
label(data$type) = "Memory or non-memory trial"
label(data$S_Angle) = "Stimulus angle (deg)"
label(data$P_Angle) = "Probe angle (deg)"
label(data$R_Angle) = "Response angle (deg)"
label(data$RT) = "Response time"
label(data$MT) = "MT"
label(data$ts_b) = "Beginning timestamp"
label(data$ts_p) = "Probe timestamp"
label(data$ts_d) = "delay timestamp"
label(data$ts_r) = "Response timestamp"
label(data$ts_m) = "Mask timestamp"
label(data$ts_e) = "End timestamp"
label(data$m_angle) = "m_angle"
label(data$m_clock) = "_clock"
label(data$S_rad) = "Stimulus angle (rad)"
label(data$P_rad) = "Probe angle (rad)"
label(data$R_rad) = "Response angle (rad)"
label(data$prevstim_rad) = "Previous stimulus angle (rad)"
label(data$prevresp_rad) = "Previous response angle (rad)"
label(data$prevprob_rad) = "Previous probe angle(rad)"
label(data$prevmem) = "Previous trial is memory?"
label(data$futurestim_rad) = "Next stimulus angle (rad)"
label(data$futureresp_rad) = "Next response angle (rad)"
label(data$subject) = "Subject"
label(data$session) = "Session"
label(data$group) = 'Group'
label(data$error) = "Error"
label(data$errorprevstim) = "Previous stim error relative to current stim"
label(data$errorprevresp) = "Previous resp error relative to current stim"
label(data$errorprevprobe) = "Previous probe error relative to current stim"
label(data$diffstim) = "Difference current-previous stim (rad)"
label(data$diffresp) = "Difference current stim-previous resp (rad)"
label(data$difffuture) = "Difference current-next stim (rad)"
label(data$difffutureresp) = "Difference current stim-next resp (rad)"
label(data$diffprevprob) = "Difference current stim-previous probe (rad)"
label(data$time) = "Time"

# Remove variables:
data$m_angle <- NULL
data$m_clock <- NULL

# exclude session 5:
data <- data[data$session != 'S5',]

# time from months to years:
data$time <- data$time/12

# Convert variables to factors:
data$session <- as.factor(data$session)
data$session <- droplevels(data$session)
data$group <- as.factor(data$group)
data$subject <- as.factor(data$subject)

# Relevel factors:
data$group <- relevel(data$group, ref = 'C')

# Keep only memory trials:
data = data[data$type == 1, ]

# time from months to days
# data$time <- data$time*30
```

```{r settings}
colors = c(C = 'gray', E = 'gold4', S = 'tomato3')
bins = 50
theme_set(theme_minimal(base_size = 15)) # ggplot theme
digits = 3 # number of digits to show in tables
```

# Summary

```{r summary}
groupedData <- data %>%
  group_by(group, session) %>%
  nest() %>%
  mutate(n = map(.x = data, .f = ~ n_distinct(.x$subject)),
         n_trials = map(.x = data, .f = ~ nrow(.x))) %>%
  unnest(c(n, n_trials))

groupedData %>%
  select(c(session, group, n)) %>%
  spread(session, n) %>%
  kable(digits = digits, booktabs = TRUE, escape = FALSE,
        caption = 'Summary of number of subjects by group and session.',
        align = c('l', rep('c', length(unique(data$session)) + 1)), 
        col.names = c(label(data$group), levels(data$session))) %>%
  kable_styling(position = "float_left",
              bootstrap_options = "striped", full_width = F) %>%
  column_spec(1:(length(unique(data$session)) + 1), "2cm") 


groupedData %>%
  select(c(session, group, n_trials)) %>%
  spread(session, n_trials) %>%
  kable(digits = digits, booktabs = TRUE, escape = FALSE,
        caption = 'Summary of number of trials by group and session.',
        align = c('l', rep('c', length(unique(data$session)) + 1)),
                col.names = c(label(data$group), levels(data$session))) %>%
  kable_styling(position = "center",
                bootstrap_options = "striped", full_width = F) %>%
  column_spec(1:(length(unique(data$session)) + 1), "2cm") 

```


```{r RawPlots, fig.cap = 'Summary of the main variables', fig.show='hold', out.width = '49%', fig.ncol = 2, fig.align='center'}
summaryHist(data, "S_rad")
summaryHist(data, "P_rad")
summaryHist(data, "R_rad")
summaryHist(data, "error")
summaryHist(data, "RT")
```
```{r}
# Removing RT>2.8 (as max RT is 3, in these trials they probably needed more time):
data = data[data$RT<2.8,]
```

# Error distribution by subject and session

```{r fig.cap = 'Error distribution by subject and session', fig.height = 40, fig.width = 8}
ggplot(data, aes(x = error, fill = group)) +
  geom_histogram(aes(y =..density..), bins = 30,
                 position = 'identity', alpha = 0.4) +
  scale_fill_manual(values = as.vector(colors)) +
  scale_color_manual(values = as.vector(colors)) +
  labs(x = label(data$error), fill = label(data$group))+
  facet_wrap(~ subject:session, ncol = 4)
```

# Preprocessing

- We remove the trials where the response time is greater than 2.8 seconds, as the maximum response time is of 3 seconds.
- We compute the outliers (error>0.7 radians) and remove the subjects with more than 50% of trials being outliers.


```{r}
# Subjects to remove, having more than 50% outlier trials (abs error>0.7):
outliers <- data %>% 
  group_by(subject, session) %>%
  summarise(outliers = sum(abs(error)>0.7), trials = n(), propout = sum(abs(error)>0.7)/n()) %>%
  filter(propout>0.5)

# Removing these subjects:
data = data %>% 
  filter(!(paste(subject, session, sep = '') %in% paste(outliers$subject, outliers$session, sep = '')))

# removing outlier trials 
#data = data[abs(data$error) < 0.7,]
```

The excluded subjects are:

```{r}
kable(outliers, digits = digits, booktabs = TRUE, escape = FALSE,
      caption = 'Outlier subjects removed from original data.',
      col.names = c(label(data$subject), label(data$session), 
                    "Number of outlier trials", "Total number of trials", 
                    "Proportion of outliers")) %>%
  kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)
```


And now this will be the amount of subjects left by session and group:
```{r}
groupedData <- data %>%
  group_by(group, session) %>%
  nest() %>%
  mutate(n = map(.x = data, .f =  ~n_distinct(.x$subject)),
         n_trials = map(.x = data, .f =  ~nrow(.x))) %>%
  unnest(c(n, n_trials))

groupedData %>%
  select(c(session, group, n)) %>%
  spread(session, n) %>%
  kable(
    caption = 'Summary of number of subjects by group and session.',
    booktabs = TRUE, escape = FALSE,
    col.names = c(label(data$group), levels(data$session))) %>%
  kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F) %>%
  column_spec(1:(length(unique(data$session)) + 1), "2cm") 
```

# Response and error distributions for each session by group 

```{r, fig.width = 12, fig.height = 3, fig.cap = 'Response distribution by group for each session.'}
data %>%
  ggplot(aes(x = R_rad, fill = group)) + 
  geom_histogram(aes(y = ..density..), bins = bins,
                 position = 'identity', alpha = 0.4) +
  stat_density(geom = "line", alpha = 1, aes(fill = NA, color = group), 
               position = "identity", show.legend = FALSE) +
  scale_fill_manual(values = as.vector(colors)) +
  scale_color_manual(values = colors) +
  labs(x = label(data$R_rad), fill = label(data$group), color = label(data$group)) +
  facet_wrap(vars(session), ncol = 4)
```
 
```{r, fig.width = 12, fig.height = 3, fig.cap = 'Error distribution by group for each session.'}
data %>%
  ggplot(aes(x = error, fill = group)) + 
  geom_histogram(aes(y = ..density..), bins = bins,
                 position = 'identity', alpha = 0.4) +
  stat_density(geom = "line", alpha = 1, aes(fill = NA, color = group), 
               position = "identity", show.legend = FALSE) +
  scale_fill_manual(values = as.vector(colors)) +
  scale_color_manual(values = colors) +
  labs(x = label(data$error), fill = label(data$group), color = label(data$group)) +
  facet_wrap(vars(session), ncol = 4)
```


# Absolute error

```{r, fig.align='center', message = FALSE, warning = FALSE, fig.height = 10, fig.width = 8, fig.cap = 'Mean error by subject trough time', eval = FALSE, include = FALSE}

for(i in seq_along(unique(data$group))){
  data %>%
    filter(group == unique(data$group)[i]) %>%
    ggplot(aes(x = time, y = abs(error), color = group)) +
    geom_jitter(width = 0.05, alpha = 0.2, show.legend = FALSE) +
    stat_summary(fun.y = mean, geom = 'point', size = 1, show.legend = FALSE) +
    stat_summary(fun.y = mean, geom = 'line', size = 1, show.legend = FALSE) +
    scale_color_manual(values=colors) +
    labs(x = label(data$time), y = "Absolute error", color = label(data$group)) +
    facet_wrap_paginate(~subject, ncol = 4, page = i) -> p
  print(p)
}
```


```{r, fig.align='center', message = FALSE, warning = FALSE, fig.height = 40, fig.width = 8, fig.cap = 'Mean error by subject through time'}
data %>%
  ggplot(aes(x = time, y = abs(error), color = group)) +
  geom_jitter(width = 0.05, alpha = 0.2, show.legend = FALSE) +
  stat_summary(fun.y = mean, geom = 'point', size = 1, show.legend = FALSE) +
  stat_summary(fun.y = mean, geom = 'line', size = 1, show.legend = FALSE) +
  scale_color_manual(values=colors) +
  labs(x = label(data$time), y = "Absolute error", color = label(data$group)) +
  facet_wrap(~ subject, ncol = 4)
```

```{r, fig.align='center', message = FALSE, warning = FALSE, fig.height = 3, fig.width = 8, fig.cap = 'Mean error by subject and group through time'}
data %>%
  ggplot(aes(x = time, y = abs(error), color = group)) +
  stat_summary(fun.y = mean, geom = 'line', show.legend = FALSE,
                position = position_dodge(width = 0.05), 
                aes(group = subject), alpha = 0.3) +
  facet_wrap(~ group) +
  stat_summary(fun.data = "mean_cl_boot", show.legend = FALSE,
                position = position_dodge(width = 0.05), 
                aes(group = group)) +
   stat_summary(fun.y = mean, geom = "line", size = 1, show.legend = FALSE,
                position = position_dodge(width = 0.05), 
                aes(group = group)) +
  scale_color_manual(values = colors) +
  theme_minimal(base_size = 15) +
  labs(x = label(data$time), y = "Absolute error", color = label(data$group)) +
  facet_wrap(~ group)
```


```{r, fig.height = 3, fig.align='center', fig.cap = 'Mean absolute error by group and session.', out.width = '70%'}
data %>%
  ggplot(aes(x = time, y = abs(error), color = group, group = group)) +
  #geom_jitter(width = 0.2, alpha = 0.2, show.legend = FALSE) +
  stat_summary(fun.data = "mean_cl_boot",
               position = position_dodge(width=0.05)) +
  stat_summary(fun.y = mean, geom = "line",  size = 1, show.legend = FALSE,
               position = position_dodge(width=0.05)) +
  scale_color_manual(values=colors) +
  labs(x = label(data$time), y = "Absolute error",
       color = label(data$group), group = label(data$group))
```

```{r}
summary(glmer(abs(error) ~ group*time + (1 + time | subject), 
      family = Gamma(link="log"), data = data))$coefficients %>%
  kable(booktabs = TRUE, escape = FALSE, digits = digits,
        caption = "Generalized linear mixed-effects model where the response is the absolute error and regressors are group and time, with random effects for the intercept and session.") %>%
  kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F) 

# require(CircGLMBayes)
# m <- circGLM(error ~ group*session, data = data)
```

# Repulsion from axes
```{r, fig.align='center', fig.cap = 'Repulsion from axes by group and session.', fig.height = 3}
data %>%
  ggplot(aes(x = S_rad, y = error, color = group, group = group, fill = group)) +
  geom_smooth(alpha = 0.2) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  facet_grid(~session) +
  labs(x = 'Stimulus postion (rad)', y = "Error",
       group = label(data$group))

binned <- data %>%
  mutate(bin = ntile(x = S_rad, n = 10)) %>%
  group_by(bin, subject, group, time) %>%
  summarise(mean_error = mean(error)) %>%
  group_by(subject, group, time) %>%
  summarise(sd_error = sd(mean_error)) %>%
  as.data.frame()
```


```{r}
anova(lm(sd_error ~ group*time, data = binned)) %>%
  kable(booktabs = TRUE, escape = FALSE, digits = digits,
        caption = "Linear model where the response is the standard deviation of the mean error computed for each of 10 bins of the stimulus position by subject and timepoint.") %>%
  kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F) 
```

```{r}
require(McSpatial)
require(sjlabelled)
require(labelled)

fit <- data %>%
  group_by(subject, time) %>%
  nest() %>%
  # mutate(Fourier = map(.x = data, .f = ~fourier(.x$error ~ .x$R_rad, q = 1, crit = "gcv"))) %>%
  mutate(data = map(.x = data, 
                    ~ mutate(.x, 
                             fourier_yhat = unlabelled(fourier(error ~ R_rad, q = 1)$yhat)))) %>%
  unnest(data) %>%
  mutate(fourier_error = fourier_yhat - error)
```


# Bias and precision

```{r, results = 'asis'}
groupedSubjSes <- data %>%
  group_by(session, subject) %>%
  nest() %>%
  mutate(JV10e = map(.x = data, .f = ~JV10_error(X = .x$R_rad, Tg = .x$S_rad)))%>%
  mutate(precision = map_dbl(JV10e, 1), bias = map_dbl(JV10e, 2), 
         group = substr(subject, 1,1), 
         time = unlist(map(data, function(x) unique(x['time'])))) %>%
  select(-c("JV10e")) 

groupedData <- groupedData %>%
  mutate(JV10e = map(.x = data, .f = ~JV10_error(X = .x$R_rad, Tg = .x$S_rad)))%>%
  mutate(precision = map_dbl(JV10e, 1), bias = map_dbl(JV10e, 2)) %>%
  select(-c("JV10e"))

aux <- unlist(lapply(levels(data$session), function(x) setNames(2,x)))
aux0 <- apply(expand.grid(c("precision", "bias"), levels(data$session)), 
              1, paste, collapse=".")

groupedData %>%
  select(group, session, precision, bias) %>%
  as.data.frame() %>%
  reshape(idvar = 'group', timevar = 'session', direction = "wide",
          v.names = c('precision', 'bias')) %>%
  select(c("group", all_of(aux0))) %>%
  kable(col.names = c(label(data$group), 
                      rep(c("Precision", "Bias"), length(levels(data$session)))), 
        row.names = FALSE, booktabs = TRUE, escape = FALSE,
        caption = "Bias and precision by group and session.",
        digits = digits) %>%
  add_header_above(c(" " = 1, aux)) %>%
  kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)
```


```{r fig.cap = 'Bias and precision by group and session.', fig.show='hold', out.width = '49%'}
groupedSubjSes %>%
  ggplot(aes(x = time, y = abs(bias), color = group, group = group)) +
  geom_jitter(width = 0.2, alpha = 0.2, show.legend = FALSE) +
  stat_summary(fun.data = "mean_cl_boot", show.legend = FALSE,
               position = position_dodge(width=0.05)) +
  stat_summary(fun.y = mean, geom = "line", size = 1, show.legend = FALSE,
               position=position_dodge(width=0.05)) +
    scale_color_manual(values=colors) +
  labs(x = label(data$time), y = "Absolute bias", 
       color = label(data$group), group = label(data$group))

groupedSubjSes %>%
  ggplot(aes(x = time, y = precision, color = group, group = group)) +
  geom_jitter(width = 0.2, alpha = 0.2, show.legend = FALSE) +
  stat_summary(fun.data = "mean_cl_boot",
               position=position_dodge(width=0.05)) +
  stat_summary(fun.y = mean, geom = "line",  size = 1, show.legend = FALSE,
               position=position_dodge(width=0.05)) +
    scale_color_manual(values=colors) +
  theme(legend.position=c(.9, .8)) +
  labs(x = label(data$time), y = "Precision", color = label(data$group), 
       group = label(data$group)) 
```

```{r, fig.align='center', message = FALSE, warning = FALSE, fig.height = 3, fig.cap = 'Bias by subject and group through time'}
groupedSubjSes %>%
  ggplot(aes(x = time, y = abs(bias), color = group, group = subject)) +
  geom_line(alpha = 0.3, show.legend = FALSE) +
  stat_summary(fun.data = "mean_cl_boot", show.legend = FALSE,
               position = position_dodge(width = 0.05), aes(group = group)) +
  stat_summary(fun.y = mean, geom = "line", size = 1, show.legend = FALSE,
               position = position_dodge(width = 0.05), aes(group = group)) +
  scale_color_manual(values = colors) +
  theme_minimal(base_size = 15) +
  labs(x = label(data$time), y = "Absolute bias", color = label(data$group)) +
  facet_wrap(~ group)
```


```{r, fig.align='center', message = FALSE, warning = FALSE, fig.height = 3, fig.cap = 'Precision by subject and group through time'}
groupedSubjSes %>%
  ggplot(aes(x = time, y = precision, color = group, group = subject)) +
  geom_line(alpha = 0.3, show.legend = FALSE) +
  stat_summary(fun.data = "mean_cl_boot", show.legend = FALSE,
               position = position_dodge(width = 0.05), aes(group = group)) +
  stat_summary(fun.y = mean, geom = "line", size = 1, show.legend = FALSE,
               position = position_dodge(width = 0.05), aes(group = group)) +
  scale_color_manual(values = colors) +
  theme_minimal(base_size = 15) +
  labs(x = label(data$time), y = "Precision", color = label(data$group)) +
  facet_wrap(~ group)
```

```{r}
summary(lme(precision ~ group * time, random = ~(1+group)|subject, data = groupedSubjSes))$varFix %>%
  kable(digits = digits, booktabs = TRUE, escape = FALSE,
        caption = 'Linear mixed-effects model where the response is precision and regressors are group, time and its interaction.') %>%
    kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)

anova(lme(precision ~ group * time, random = ~(1+group)|subject, data = groupedSubjSes)) %>%
  kable(digits = digits, booktabs = TRUE, escape = FALSE,
        caption = "Anova for the linear mixed-effects model where the response is precision and regressors are group, time and its interaction.") %>%
    kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)
```


```{r }
summary(lme(abs(bias) ~ group * time, random = ~(1+group)|subject, data = groupedSubjSes))$varFix %>%
  kable(digits = digits, booktabs = TRUE, escape = FALSE,
        caption = 'Linear mixed-effects model where the response is bias and regressors are group, time and its interaction.') %>%
    kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)

anova(lme(abs(bias) ~ group * time, random = ~(1+group)|subject, data = groupedSubjSes)) %>%
  kable(digits = digits, booktabs = TRUE, escape = FALSE,
        caption = 'Anova of a linear mixed-effects model where the response is bias and regressors are group, time and its interaction.') %>%
    kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)
```


# Serial bias



```{r warning = FALSE}
window = pi/3
step = pi/20

gr <- split(data, 
            list(data$group, data$session), drop = TRUE)
serialbias <- lapply(gr, function(x) 
  serial_bias(prevcurr = x$diffstim, error = x$error, window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(serialbias, aes(x = x, y = m), color = group) +
  geom_line() +
  geom_hline(yintercept=0, color = "black") +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.4) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  ggtitle('Serial bias') + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```

```{r}
# DoG: normalized first derivative of a Gaussian with fixed location hyperparameter mu=0
#Cross-validation to find hyperparameter sigma
dnorm_deriv1 <- function(x, mean = 0, sd = 1) {
  return(-(x/(sd^2))*dnorm(x, mean = mean, sd = sd))
} 
dnorm_deriv3 <- function(x, mean = 0, sd = 1) {
  return((((-3*x*sd^2)-x^3)/(sd^6))*dnorm(x, mean, sd = 1))
} 

crossValSigma <- function(sigma, data, derivative = 1){
  #data$DoG <- ddnorm(data$diffstim, mean = 0, sd = sigma)
  if(derivative == 1){
    data$DoG <- dnorm_deriv1(data$diffstim)}
  else{if(derivative == 3){
    data$DoG <- dnorm_deriv3(data$diffstim)}}
  smp_size <- floor(0.67 * nrow(data))
  train_id <- sample(seq_len(nrow(data)), size = smp_size)
  train <- data[train_id, ]
  test <- data[-train_id, ]
  mod <- lm(error ~ group*time*DoG, data = train)
  pred <- predict(mod, test)
  MSE <- mean((na.omit(pred - test$error))^2)
  return(MSE)
}

require(miscTools)
Sigma <- seq(0.1, 1.9, by = 0.1)
sim <- lapply(Sigma, function(x) replicate(1000, crossValSigma(x, data, derivative = 1))) 
mean_SEM <- unlist(lapply(sim, mean))
min_SEM <- min(mean_SEM)
sigma <- Sigma[mean_SEM == min_SEM]

sim3 <- lapply(Sigma, function(x) replicate(1000, crossValSigma(x, data, derivative = 3))) 
mean_SEM3 <- unlist(lapply(sim3, mean))
min_SEM3 <- min(mean_SEM3)
sigma3 <- Sigma[mean_SEM3 == min_SEM3]

data$DoG <- dnorm_deriv1(data$diffstim, mean = 0, sd = sigma)
data$DoG3 <- dnorm_deriv3(data$diffstim, mean = 0, sd = sigma3)

if(min_SEM < min_SEM3){
  mod <- lme(error ~ group*time*DoG,  random = ~(1+group)|subject, data = data, na.action = na.omit)
}else{mod <- lme(error ~ group*time*DoG3, random = ~(1+group)|subject, data = data, na.action = na.omit)
}
anova(mod) %>%
  kable(digits = digits, booktabs = TRUE, escape = FALSE,
        caption = 'Summary of a linear model where the response is the error and regressors are group, time, a derivative of gaussian and its interaction.') %>%
    kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)


mod_fit <- expand.grid(x = seq(0, pi/2, 0.05), group = unique(data$group), 
                       time = unique(data$time))
mod_fit$session <- factor(mod_fit$time, levels = c(0, 0.25, 0.5, 1, 2), labels = c('S1', 'S2', 'S3', 'S4', 'S5'))
if(min_SEM < min_SEM3){
  mod_fit$DoG <- dnorm_deriv1(mod_fit$x, mean = 0, sd = sigma)
}else{mod_fit$DoG3 <- dnorm_deriv3(mod_fit$x, mean = 0, sd = sigma3)
}
mod_fit$pred <- predict(mod, newdata = mod_fit, level = 0)

```



```{r warning = FALSE}
serialbiasprevresp <- lapply(gr, function(x) 
  serial_bias(prevcurr = x$diffresp, error = x$error, window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(serialbiasprevresp, aes(x = x, y = m), color = group) +
  geom_line() +
  geom_hline(yintercept=0, color = "black") +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.4) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  ggtitle('Serial bias to previous response') + 
  labs(x = "Difference previous response - current stimulus", y = 'Error') 
```


```{r warning = FALSE, fig.height = 40, fig.width = 8, fig.cap = 'Folded serial bias by subject and session'}
window = pi/4
step = pi/10

subj_sb <- split(data, 
            list(data$subject, data$session), drop = TRUE)
subj_foldedserialbias <- lapply(subj_sb, function(x) 
  folded_serial_bias(prevcurr = x$diffstim, error = x$error, window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1), subject = substr(id, 1, 3)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(subj_foldedserialbias, aes(x = x, y = m), color = group) +
  geom_line() +
  geom_hline(yintercept=0, color = "black") +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.4) +
  facet_wrap(~ subject + session, ncol = 4) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  ggtitle('Folded serial bias') + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
``` 

```{r warning = FALSE}
window = pi/5
step = pi/20
foldedserialbias <- lapply(gr, function(x) 
  folded_serial_bias(prevcurr = x$diffstim, error = x$error, window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(foldedserialbias, aes(x = x, y = m), color = group) +
  geom_line() +
  geom_hline(yintercept=0, color = "black") +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.4) +
  #geom_line(data = mod_fit, aes(x = x, y = pred)) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  ggtitle('Folded serial bias') + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```


```{r warning = FALSE}
foldedserialbiasprevresp <- lapply(gr, function(x) 
  folded_serial_bias(prevcurr = x$diffresp, error = x$error, window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(foldedserialbias, aes(x = x, y = m), color = group) +
  geom_line() +
  geom_hline(yintercept=0, color = "black") +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.4) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  ggtitle('Folded serial bias to previous response') + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```


```{r}
data %>%
  filter(session != 'S5') %>%
  ggplot(aes(x = diffstim, y = error), fill = group) +
#  geom_point() +
  stat_smooth(aes(fill = group), color = 'black', method = "loess", span = window) +
  geom_hline(yintercept=0, color = "black") +
  #geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.4) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  labs(x = "Difference previous - current stimulus") 
```


```{r}
data %>%
  filter(session != 'S5') %>%
  ggplot(aes(x = diffresp, y = error), color = group) +
#  geom_point() +
  stat_smooth(aes(fill = group), color = 'black', method = "loess") +
  geom_hline(yintercept=0, color = "black") +
  #geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.4) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  labs(x = "Difference previous response - current stimulus")

```
